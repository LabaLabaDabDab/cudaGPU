# Лабораторная работа №1

## Задание:
Выделить на GPU массив arr из 10^9 элементов типа float и инициализировать его с помощью ядра следующим образом: arr[i] = sin((i%360)*Pi/180). Скопировать массив в память центрального процессора и посчитать ошибку err = sum_i(abs(sin((i%360)*Pi/180) - arr[i]))/10^9. Провести исследование зависимости результата от использования функций: sin, sinf, __sinf. Объяснить результат. Проверить результат при использовании массива типа double.

## Характеристики устройства
```
Device name: NVIDIA GeForce RTX 5070 Ti
Number of multiprocessors: 70
Global memory size: 17094475776 bytes
Max threads per block: 1024
Max grid size: 2147483647 x 65535 x 65535
Max block dimensions: 1024 x 1024 x 64
```

## Результаты работы
### Float 
```
sin    mean absolute error = 8.5060793906e-09
Execution time (kernel_sin): 6.070 ms

sinf   mean absolute error = 8.5060793906e-09
Execution time (kernel_sinf): 10.460 ms

__sinf mean absolute error = 1.2281006453e-07
Execution time (kernel_fast_sinf): 99.520 ms
```

### Double
```
sin    mean absolute error = 9.6662645006e-18
Execution time (kernel_sin): 81.858 ms

sinf   mean absolute error = 4.6123523244e-08
Execution time (kernel_sinf): 176.368 ms

__sinf mean absolute error = 1.2778164421e-07
Execution time (kernel_fast_sinf): 9.677 ms
```

## Вывод
### 1. Точность
Функции sinf и __sinf всегда вычисляют синус в одинарной точности (float). Если им передать аргумент типа double, он сначала неявно приводится к float, а уже потом используется в вычислении. Поэтому и при массиве типа float, и при массиве типа double средняя ошибка для sinf / __sinf остаётся на уровне 7–9 знака.
Функция sin, наоборот, работает в двойной точности (double). Если ей передать float, аргумент конвертируется в double, но результат всё равно потом обрезается до float, и точность ограничена одинарной арифметикой. Зато при использовании sin вместе с массивом типа double всё вычисление от аргумента до результата идёт в двойной точности, поэтому достигается минимальная ошибка о на уровне 18-го знака.

### 2. Время
Если нужна максимальная точность, следует использовать sin с массивом типа double.
Если достаточно точности уровня float и важна скорость, можно использовать __sinf, понимая, что ошибка будет больше.
Использование sinf/__sinf с массивом double не повышает точность по сравнению с float, так как вычисления всё равно выполняются в одинарной точности.
